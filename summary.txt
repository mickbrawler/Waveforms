	In our first meeting, Dr. Ghosh gave a basic overview of neutron stars, relativity, and gravitation waves. We spoke of the Hubble constant and the methods by which the age of the universe can be determined. In later meetings, we worked on reinforcing my knowledge of basic Linux, Vim, Tmux, and Git commands to get an understanding of the kind of workflow one should have when coding. From here, having already had a background in Python, we moved on to applications of NumPy. Basic array manipulation and indexing, as well as boolean masking and indexing, were reviewed and applied to different projects. 
	
	The first assignment was to code a program that would find all the prime numbers from 0 up to the inputted value. Dr. Ghosh introduced a version of the code that was in C to give me an idea of a good algorithm to use, and we soon translated it into Python. The difference in computing speed became very apparent when compared to each other. Python code is interpreted, C's is compiled. The C code ran many times faster than the Python code. Numpy largely resolves this issue, as even though it is a python package, it runs in C. It is a means of coding in the simple syntax Python offers, with the efficiency C is known for. The next objective was to eliminate any loops in the Python code using arrays. Working with arrays is far more efficient than with loops. In my first attempt, I was successful at eliminating one of the for loops in the program; later Dr. Ghosh showed how both could be eliminated. Afterward, the NumPy-based program and the C program were compared. While the NumPy code was far faster than the original python code, it was still outmatched by the C code. Well-written C code will always run faster than NumPy code, but NumPy does the job well enough.

	The second assignment was to code a program that, when fed frequency, amplitude, starting and ending times, attenuation function, and initial phase values, would produce a sinusoidal wave. Technically three are produced: the noise, the signal, and the total combined data. Under normal circumstances, the Laser Interferometer Gravitational-Wave Observatory (LIGO) receives constant noise and detects gravitational waves embedded inside the noise. The coded program should produce a data set where the noise and signal have the same resolution when combined.

	The last assignment's objective is to use this newly created waveform function to test methods of detecting gravitational-wave signals in raw data. Since the waveform function provides the actual properties of the signal, the extracted signal found in the detection function can be compared, and clearly show the accuracy of the method used. Cross-correlation is the first method that will be used to identify the location and properties of the signal. Detecting, isolating, and analyzing extracted signals is analogous to the work LIGO does, on a far smaller scale of complexity here.
